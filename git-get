#!/usr/bin/env bash

######################################
# git ext_name
#
#
# Installation :
# Add this to the same directory that your git executable is in, and make sure it has executable
# permissions : i.e.: chmod o+x  git-get
#
# git-same as git clone but without the cloning
#
# Usage:
#
# @author Andrew Druffner andrew@nomstock.com
######################################


#####################
#
# Determine platform
# http://stackoverflow.com/a/18434831
#####################

# NOTE: on macOS, this requires GNU findutils,
# installed using e.g. brew install findutils:
# https://brew.sh/
# https://apple.stackexchange.com/a/69332
case "${OSTYPE}" in
    darwin*)
        grep='ggrep'
        xargs='gxargs'
    ;;
    linux-*)
        grep='grep'
        xargs='xargs'
    ;;
    *)
        echo 'ERROR'
        echo "unsupported operating system: ${OSTYPE}"
        exit 1
    ;;
esac

#####################
#
# GetOpts
# http://stackoverflow.com/a/16496491
#####################


#########################
# The command line help #
#########################
usage() {
    echo "Usage: git get [option...] <repository> [<directory>]"
    echo
    echo "   -b <branch name>  Branch  - branch to download, defaults to master"
    echo "   -a [archive type] Archive - zip,tar download as archive, defaults to tar"
    echo "   -V                Verbose - Shows debugging output"
    echo "   -d                Dry Run - Downloads repo to a temp directory"
    echo "   -v                Version - shows version"
    echo "   -h                Help    - show usage"
    echo
    1>&2;exit 1
}



# intialization
archive_type=tar
branch=master
dir=
repo_path=
e_messages=
v_messages=
version=1.0.0
# colon after the argument means it requires a value assigned to it
while getopts "b:a:Vdv:h" o;do
    case "${o}" in
        b)

            branch="${OPTARG}"
            v_messages+="-b:branch set to ${branch}\n";
        ;;
        a)
            archive="${OPTARG}"
            v_messages+="-a:archive set to ${archive}\n";
        ;;
        V)
            VERBOSE="TRUE"
            v_messages+="-V:verbose enabled \n";
        ;;
        d)
            DRY_RUN="TRUE"
            v_messages+="-d:dry run enabled \n";
        ;;
        v)
            echo "git-get version $version";
            exit;
        ;;
        h,*)
            usage
            exit;
        ;;
    esac
done
     shift $((OPTIND-1));


validate(){

    if [ -z "${1}" ]; then
        e_messages+="Error:Missing <repository> \n";
        usage;
        end;
    else
        repo_path="${1}"
    fi

    if [ "$2" ]; then
        dir="${2}"
    fi

}

show_errors () {
    echo -e "$*"
    exit 1;
}

show_verbose () {
    if [ ! -z "${VERBOSE}" ]
    then
        echo -e "$*"

    fi
}



end(){
    show_errors "${e_messages}"
    exit;
}


setRepoPath(){
    if [ -z "${1}" ]; then
        e_messages+="Error:Missing <repository> \n";
        end;
    else
        repo_path="${1}"
        v_messages+="repo_path:${repo_path} \n";
    fi
}




setDirectory(){
    if [ "${dir}" ]; then
    v_messages+="dir:${dir} \n";
        return
    fi

    re="([^/]+)\.git"
    re_no_extension="([^/]+)$"
    if [[ $repo_path =~ $re ]]; then
        dir=${BASH_REMATCH[1]}

        elif [[ $repo_path =~ $re_no_extension ]]; then
        dir=${BASH_REMATCH[1]}
    else
        e_messages+="invalid path $repo_path \n";
        end;
    fi
v_messages+="dir:${dir} \n";


}



get(){

    local temp="${TMPDIR:-/tmp}"
    local dirNameTarget=$dir
    local dirPathTarget="./${dir}";
    local dirDryRunTarget=$temp/$dir
    local currentDirectory=$(pwd)


    local cmd_options='--depth=1 --branch='"${branch}"' '"${repo_path}"' '"${dirPathTarget}"


    if [ ! -z "${DRY_RUN}" ]
    then

        echo "dry run..."
        dirPathTarget="${dirDryRunTarget}";
        rm -rf "${dirDryRunTarget}";

        local cmd_options='--depth=1 --branch='"${branch}"' '"${repo_path}"' '"${dirPathTarget}"


        echo "git clone ${cmd_options}"
        echo "git submodule update --init --recursive"
        echo 'rm -rf ./'"${dir}"'/.git'



    fi

    if git clone ${cmd_options} ; then
        if  cd "${dirPathTarget}" ; then

            git submodule update --init --recursive;


            if [ "$currentDirectory" != "$(pwd)" ]; then # be really sure
                rm -rf ".git";
                cd - 1>/dev/null


            fi


        fi

    fi


}





######## MAIN ###########
validate  "${@}"
v_messages+="arguments:${@} \n";
setRepoPath "${1}"
setDirectory   "${@}"
show_verbose "${v_messages}"
get
show_errors "${e_messages}"