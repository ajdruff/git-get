#!/bin/bash

######################################
# git ext_name
#
#
# Installation :
# Add this to the same directory that your git executable is in, and make sure it has executable
# permissions : i.e.: chmod o+x  git-get
#
# git-same as git clone but without the cloning
#
# Usage:
#
# @author Andrew Druffner andrew@nomstock.com
######################################

#####################
#
# Determine platform
# http://stackoverflow.com/a/18434831
#####################

# NOTE: on macOS, this requires GNU findutils,
# installed using e.g. brew install findutils:
# https://brew.sh/
# https://apple.stackexchange.com/a/69332

case "${OSTYPE}" in
darwin*)
    grep='ggrep'
    xargs='gxargs'
    ;;
linux-*)
    grep='grep'
    xargs='xargs'
    ;;
*)
    echo 'ERROR'
    echo "unsupported operating system: ${OSTYPE}"
    exit 1
    ;;
esac

#####################
#
# GetOpts
# http://stackoverflow.com/a/16496491
#####################

#########################
# The command line help #
#########################
usage() {
    echo "Usage: git get [option...] <repository> [<directory>]"
    echo
    echo "   -b <BRANCH name>  Branch  - The branch you want to download. defaults to master"
    echo "   -a [compress type] Archive - Download as a zip or tar archive, defaults to tar"
    echo "   -x                Export -  When used in combination with -a, abides by export-ignore rules in .gitattributes"
    echo "   -V                Verbose - Shows verbose output"
    echo "   -d                Dry Run - Uses system tmp directory for downloads, Ignored when -a is used"
    echo "   -v                Version - shows version"
    echo "   -h                Help    - show usage"
    echo
    1>&2
    exit 1
}

#version
version=1.0.0
#defaults
BRANCH=master
COMPRESS_TYPE=tar
ARCHIVE_ON="FALSE"
VERBOSE_ON="TRUE"
DRY_RUN_ON="FALSE"
# intialization
WORKING_DIRECTORY=$(pwd)
REPO_PATH=
E_MSG=
V_MSG=
# colon after the argument means it requires a value assigned to it
while getopts ":c:aVdv:hR:" o; do
    case "${o}" in
    b)

        BRANCH="${OPTARG}"
        V_MSG+="-b:BRANCH set to ${BRANCH}\n"
        ;;
    R)
        if [[ $OPTARG =~ ^[0-9]+$ ]]; then
            level=$OPTARG
        else
            level=1
        fi
        ;;
    c)
        COMPRESS_ON="${OPTARG}"
        COMPRESS_ON="TRUE"
        COMPRESS_TYPE=
        V_MSG+="-c:compression set to ${COMPRESS_ON}\n"
        ;;
    a)
        ARCHIVE_ON="TRUE"
        V_MSG+="-a:archive enabled. uses git clone --archive flag which respects .gitattributes settings such as  export-ignore\n"
        ;;
    V)
        VERBOSE_ON="TRUE"
        V_MSG+="-V:verbose enabled \n"
        ;;
    d)
        DRY_RUN_ON="TRUE"
        V_MSG+="-d:dry run enabled \n"
        ;;
    v)
        echo "git-get version $version"
        exit
        ;;
    h,*)
        usage
        exit
        ;;
    esac
done
shift $((OPTIND - 1))

# whether we want git to be removed
_RMGIT() {
    return 0
}

_DRY_RUN_ON() {

    if [ ! -z "${DRY_RUN_ON}" ]; then
        V_MSG+="dry run detected \n"
        return 0
    else
        V_MSG+="dry run not detected \n"
        return 1
    fi

}

_COMPRESS_ON() {

    if [ ! -z "${COMPRESS_ON}" ]; then
        return 0
    else
        return 1
    fi

}

_ZIP() {
    if [ "${COMPRESS_ON}" == "zip" ]; then
        return 0
    else
        return 1
    fi
}

_TAR() {
    if [ "${COMPRESS_ON}" == "tar" ]; then
        return 0
    else
        return 1
    fi
}

_RESPECT_ARCHIVE_ON_IGNORE() {

    if [ ! -z "${RESPECT_ARCHIVE_ON_IGNORE}" ]; then
        return 0
    else
        return 1
    fi

}

if (_COMPRESS_ON); then
    echo 'compress'+$COMPRESS_ON
else
    echo 'dont compress'+$COMPRESS_ON
fi

exit

validate() {

    if [ -z "${1}" ]; then
        E_MSG+="Error:Missing <repository> \n"
        usage
        end
    else
        REPO_PATH="${1}"
    fi

    if [ "$2" ]; then
        DEST_DIR_NAME="${2}"
    fi

}

show_errors() {
    echo -e "$*"
    exit 1
}

show_verbose() {
    if [ ! -z "${VERBOSE_ON}" ]; then
        echo -e "$*"

    fi
}

end() {
    show_errors "${E_MSG}"
    exit
}

setRepoPath() {
    if [ -z "${1}" ]; then
        E_MSG+="Error:Missing <repository> \n"
        end
    else
        REPO_PATH="${1}"
        V_MSG+="REPO_PATH:${REPO_PATH} \n"
    fi
}

setDirectory() {
    if [ "${DEST_DIR_NAME}" ]; then
        V_MSG+="DEST_DIR_NAME:${DEST_DIR_NAME} \n"
        return
    fi

    re="([^/]+)\.git"
    re_no_extension="([^/]+)$"
    if [[ $REPO_PATH =~ $re ]]; then
        DEST_DIR_NAME=${BASH_REMATCH[1]}

    elif [[ $REPO_PATH =~ $re_no_extension ]]; then
        DEST_DIR_NAME=${BASH_REMATCH[1]}
    else
        E_MSG+="invalid path $REPO_PATH \n"
        end
    fi
    V_MSG+="DEST_DIR_NAME:${DEST_DIR_NAME} \n"

}

_get() {

    #echo "git clone ${cmd_options}"

    return 0

    git clone --no-checkout https://github.com/tailwindcss/tailwindcss.git
    cd tailwindcss
    git compress -o latest.zip HEAD
    unzip ./latest.zip
    git submodule update --init --recursive
    find . -name ".git" -type d -exec rm -rf {} \; 2>/dev/null

}

getDestinationDirPath() {
    local dir_name="${1}"
    local target="./${DEST_DIR_NAME}"
    local temp="${TMPDIR:-/tmp}"
    if (_DRY_RUN_ON); then
        result=$temp/$dir
    elif (_COMPRESS_ON); then
        result=$temp/$dir
    fi
    echo ${result}

}

_compressUsingGitBuiltin() {

    # compress respects export-ignore but doesnt get submodules, so we'll fix that
    git compress -o "${compressName}".tar.gz "${BRANCH}"
    tar -xzf "${compressName}".tar.gz
    rm "${compressName}".tar.gz

    git submodule update --init --recursive
    _RMGIT && find . -name ".git" -type d -exec rm -rf {} \; 2>/dev/null

    ZIP && zip "$currentDirectory"/"${compressName}".zip . 1>/dev/null
    TAR && tar -zcvf "$currentDirectory"/"${compressName}".tar.gz . --exclude=*.git 1>/dev/null

    cd - 1>/dev/null

}

_compress() {
    # _compresss to zip or tar but doesn't use git native compress

    #compressName="${1}"`#`

    git checkout "${BRANCH}"
    git submodule update --init --recursive
    find . -name ".git" -type d -exec rm -rf {} \; 2>/dev/null

    ZIP && zip "$currentDirectory"/"${compressName}".zip . 1>/dev/null
    TAR && tar -zcvf "$currentDirectory"/"${compressName}".tar.gz . --exclude=*.git 1>/dev/null

    cd - 1>/dev/null

}

get() {

    local temp="${TMPDIR:-/tmp}"
    local destinationDirPath=$(getDestinationDirPath "${DEST_DIR_NAME}")
    local currentDirectory=$(pwd)
    local compressName="${DEST_DIR_NAME}"-"${BRANCH}"

    local cmd_options='--depth=1 --BRANCH='"${BRANCH}"' '"${REPO_PATH}"' '"${destinationDirPath}"

    (_COMPRESS_ON || _DRY_RUN_ON) && rm -rf "${destinationDirPath}"

    _DRY_RUN_ON && echo "git clone ${cmd_options}"
    _DRY_RUN_ON && echo "git submodule update --init --recursive"
    _DRY_RUN_ON && echo "rm -rf ${destinationDirPath}"

    if git clone --no-checkout ${cmd_options}; then #1
        if cd "${destinationDirPath}"; then         #2

            git submodule update --init --recursive

            if [ "$currentDirectory" != "$(pwd)" ]; then #3 for safety

                # remove .git directory
                find . -name ".git" -type d -exec rm -rf {} \; 2>/dev/null

                _COMPRESS_ON && _compress
                _ARCHIVE_ONE && _export

            fi

            #3

        fi #2
    fi     #1

}

######## MAIN ###########
#validate "${@}"
#V_MSG+="arguments:${@} \n"
#setRepoPath "${1}"
#setDirectory "${@}"
#show_verbose "${V_MSG}"
#get
#show_errors "${E_MSG}"
echo 'awesome'
