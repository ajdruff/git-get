#!/bin/bash

######################################
# git ext_name
#
#
# Installation :
# Add this to the same directory that your git executable is in, and make sure it has executable
# permissions : i.e.: chmod o+x  git-get
#
# git-same as git clone but without the cloning
#
# Usage:
#
# @author Andrew Druffner andrew@nomstock.com
######################################

#####################
#
# Determine platform
# http://stackoverflow.com/a/18434831
#####################

# NOTE: on macOS, this requires GNU findutils,
# installed using e.g. brew install findutils:
# https://brew.sh/
# https://apple.stackexchange.com/a/69332

case "${OSTYPE}" in
darwin*)
    grep='ggrep'
    xargs='gxargs'
    ;;
linux-*)
    grep='grep'
    xargs='xargs'
    ;;
*)
    echo 'ERROR'
    echo "unsupported operating system: ${OSTYPE}"
    exit 1
    ;;
esac

#####################
#
# GetOpts
# http://stackoverflow.com/a/16496491
#####################

# Argbash Parser
source "$(dirname "${BASH_SOURCE[0]}")/git-get-parser.sh"
getRepoPath() {

    echo "${_arg_repository}"

}

show_verbose() {
    #  _COMPRESS && echo 'compress is on'

    if [ $_arg_verbose -le 2 ]; then
        return

    fi

    printf "compression  is " && (COMPRESS_ON && echo "on") || echo "off"
    printf "zip is " && (ZIP_ON && echo "on") || echo "off" #alternate
    printf "tar is " && (TAR_ON && echo "on") || echo "off"
    printf "keep_repo is " && (KEEP_REPO_ON && echo "on") || echo "off"

    printf "export is " && (EXPORT_ON = on && echo "on") || echo "off"
    printf "dry_run is " && (DRY_RUN_ON = on && echo "on") || echo "off"
    printf "verbose is " && (VERBOSE_ON && echo "on") || echo "off"

    printf "'%s' is %s\\n" 'version' "$_arg_version"
    printf "Value of '%s': %s\\n" 'repository' "$_arg_repository"
    printf "Value of '%s': %s\\n" 'directory' "$_arg_directory"

    echo -e "${V_MSG}"

}
show_errors() {
    echo -e "${E_MSG}"
}
getDestinationDirName() {

    : ${1? ERROR Function: ${FUNCNAME[0]}() Usage: " ${FUNCNAME[0]} repo_path"}



    # first check if a directory name was included as a positional paramater, if so, use return it.
    if [  "${_arg_directory}" != null ]; then
result="${_arg_directory}"

echo "${result}"

        return 0
    fi


    #if not explicitly set, derive it from the repo path
    local repo_path="${1}"
    local result
    local re="([^/]+)\.git"
    local re_no_extension="([^/]+)$"
    if [[ $repo_path =~ $re ]]; then
        result=${BASH_REMATCH[1]}

    elif [[ $repo_path =~ $re_no_extension ]]; then
        result=${BASH_REMATCH[1]}
    else
        E_MSG+="invalid path $repo_path \n"
        end
    fi
    V_MSG+="DEST_DIR_NAME:${result} \n"

    echo "${result}"
    return 0;
}

getDestinationDirPath() {

    : ${1? ERROR Function: ${FUNCNAME[0]}() Usage: " ${FUNCNAME[0]} dir_name"}

    local dir_name="${1}"
    local result="${WORKING_DIR_PATH}/${dir_name}"
    (DRY_RUN_ON || COMPRESS_ON) && result=$TEMP_DIR_PATH/$dir_name

    echo ${result}

}

COMPRESS_ON() {

    test $_arg_zip = on || test $_arg_tar = on
    return $?

}

ZIP_ON() {

    test $_arg_zip = on
    return $?

}

TAR_ON() {

    test $_arg_tar = on
    return $?

}

EXPORT_ON() {

    test $_arg_export = on
    return $?

}

DRY_RUN_ON() {

    test $_arg_dry_run = on
    return $?

}

VERBOSE_ON() {
    test $_arg_verbose -gt 0
    return $?

}

KEEP_REPO_ON() {

    test $_arg_keep_repo = on
    return $?

}

getCompressType() {

    ZIP_ON && echo 'zip'
    TAR_ON && echo 'tar'
    (! ZIP_ON && ! TAR_ON) && echo null

}
validate() {
    # initial validation is done by the argbash parser.
    # Here we add our own rules to ensure user is warned that their options may not make sense
    TAR_ON && ZIP_ON && die 'You specified both tar and zip, please specify only one and try again'
    (! TAR_ON && ! ZIP_ON) && EXPORT_ON && die "If you want to export, you need to specify the --zip,-z or --tar,-t option to provide the compression type. Please try again"

}

init() {
    # intialization
    E_MSG=
    V_MSG=
    VERSION="${_arg_version}"
    readonly BRANCH="${_arg_branch}"
    readonly COMPRESS_TYPE="$(getCompressType)"
    readonly WORKING_DIR_PATH=$(pwd)
    readonly TEMP_DIR_PATH="${TMPDIR:-/tmp}"
    readonly REPO_PATH="$(getRepoPath)"
    readonly DEST_DIR_NAME=$(getDestinationDirName "${REPO_PATH}")
    readonly DEST_DIR_PATH=$(getDestinationDirPath "${DEST_DIR_NAME}")
    V_MSG+="BRANCH:${BRANCH} \n"
    V_MSG+="COMPRESS_TYPE:${COMPRESS_TYPE} \n"
    V_MSG+="REPO_PATH:${REPO_PATH} \n"
    V_MSG+="DEST_DIR_NAME:${DEST_DIR_NAME} \n"
    V_MSG+="DEST_DIR_PATH:${DEST_DIR_PATH} \n"
    V_MSG+="WORKING_DIR_PATH:${WORKING_DIR_PATH} \n"
    V_MSG+="VERSION:${VERSION} \n"
}

saferRmdir() {

    # check to see that you are not trying to delete root
    # check to see that what you are trying to delete is either in /tmp
    # OR in a subdirectory that matches the working directory that you started from

    : ${1? ERROR Function: ${FUNCNAME[0]}() Usage: " ${FUNCNAME[0]} dir_path"}
    local dir_path="${1}"
    local in_temp=false
    local in_working_dir=false
    local is_root=true

    local can_delete=false

    [ $dir_path != "/" ] && is_root=false

    case $dir_path/ in
    "${TEMP_DIR_PATH}"/*) in_temp=true ;;
    *) int_temp=false ;;
    esac

    case $dir_path/ in
    "${WORKING_DIR_PATH}"/*) in_working_directory=true ;;
    *) in_working_directory=false ;;
    esac

    (test $in_temp = true || test $in_working_directory = true) && (test is_root=false) && rm -rf $dir_path

}

_checkout() {

    # Note the difference between Working Directory and Destination Directory.
    # Working directory is where you started from, where you called the script from
    # Destination directorys is where you download the repo files.
    # Destination directory will be tmp during dry run and compress.
    # Working directory is where we want to place the compressed archives

    echo_verbose "Checking out $BRANCH..." 2
    ! EXPORT_ON && (git checkout -q "${BRANCH}" || die "ERROR: line ${LINENO} ,${FUNCNAME[0]}() Failed to check out branch ${BRANCH}, exiting")

}

_compress() {


    local file_name="${DEST_DIR_NAME}"-"${BRANCH}"

    COMPRESS_ON && echo_verbose "Compressing files..." 1
    COMPRESS_ON && echo_verbose "Compressing files  using ${COMPRESS_TYPE}" 2

    ZIP_ON && echo_verbose "Zip command: zip $WORKING_DIR_PATH/${file_name}.zip $PWD" 3
    ZIP_ON && (zip "$WORKING_DIR_PATH"/"${file_name}".zip $PWD 1>/dev/null || die "ERROR: line ${LINENO} ,${FUNCNAME[0]}() Failed to zip, exiting")

    TAR_ON && echo_verbose "Tar Command: tar -zcvf $WORKING_DIR_PATH/${file_name}.tar.gz -C $(dirname ${DEST_DIR_PATH}) ${DEST_DIR_NAME}" 3
    TAR_ON && (tar -zcvf "$WORKING_DIR_PATH"/"${file_name}".tar.gz -C $(dirname ${DEST_DIR_PATH}) "${DEST_DIR_NAME}" 1>/dev/null || die "ERROR: line ${LINENO} ,${FUNCNAME[0]}() Failed to tar, exiting")

    (COMPRESS_ON || DRY_RUN_ON) && echo_verbose "Deleting temporary files..." 3 && saferRmdir "${DEST_DIR_PATH}"

}

_export() {

    EXPORT_ON && echo_verbose "-x:Using git archive command to export..." 1
    EXPORT_ON && (git archive -o latest.tar.gz HEAD 1>/dev/null && tar -xzvf latest.tar.gz 1>/dev/null && rm latest.tar.gz 1>/dev/null || die "ERROR: line ${LINENO} ,${FUNCNAME[0]}() export failed, exiting...")

}

_update_submodules() {

    echo_verbose "Updating submodules..." 2

    git submodule update -q --init --recursive || die "ERROR: ${FUNCNAME[0]}() Failed to update git submodules, exiting"

}

_rm_git() {

    echo_verbose "Removing git directory" 2

    [ "$WORKING_DIR_PATH" != "$(pwd)" ] || die "ERROR: line ${LINENO} ,${FUNCNAME[0]}()  Refusing to delete wrong .git directory, exiting" # this means you were about delete the .git of the main directory

    # remove .git directory unless we tell it not to with the -k option
    KEEP_REPO_ON && echo_verbose "-k: Keeping .git repository files ..." 1 || echo_verbose "-k:removing .git repository files.." 1
    KEEP_REPO_ON || find $PWD -maxdepth 1 -name ".git" -type d -exec rm -rf {} \; # this will always return a $?=1 because of recursion, unless maxdepth=1 is used.
    KEEP_REPO_ON || ([ -d .git ] && die "ERROR: line ${LINENO} ,${FUNCNAME[0]}() Failed to remove .git, exiting")

}

echo_verbose() {

    (($2 <= $_arg_verbose)) && echo "${1}"

}

_show_download_message() {

    COMPRESS_ON && (echo_verbose "downloading $COMPRESS_TYPE of branch ${BRANCH} from repo "${REPO_PATH}"...." 0)
    ! COMPRESS_ON && (echo_verbose "downloading  branch ${BRANCH} from repo "${REPO_PATH}"..." 0)
    echo_verbose "Cloning repository..." 1

}

_git_clone() {

 
  local cmd_options='--depth=1 --branch='"${BRANCH}"' '"${REPO_PATH}"' '"${DEST_DIR_PATH}"
     VERBOSE_ON && echo_verbose "using clone command: git clone --no-checkout ${cmd_options}" 3

   git clone -q --no-checkout ${cmd_options} 1>/dev/null || die "ERROR: line ${LINENO} ,${FUNCNAME[0]}() Failed git clone"


}

get() {

    # remove the target directory if compressed or dry_run since its in temp and will block if it already exists

    _show_download_message

    _git_clone

    cd "${DEST_DIR_PATH}" 1>/dev/null || die "ERROR: line ${LINENO} ,${FUNCNAME[0]}() Failed to change directory to ${DEST_DIR_PATH}"

    _checkout

    _export

    _update_submodules

    _rm_git
    _compress

    cd - 1>/dev/null

    # NOT NEEDED:  COMPRESS_ON && EXPORT_ON && _export "${file_name}" # compress respecting .gitattributes

}

######## MAIN ###########

validate

init
show_verbose

#die ("DIE! ${LINENO}")
get
show_verbose

#show_errors
